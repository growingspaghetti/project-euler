// Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
// Triangle 	  	Tn=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
// Pentagonal 	  	Pn=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
// Hexagonal 	  	Hn=n(2n−1) 	  	1, 6, 15, 28, 45, ...

// It can be verified that T285 = P165 = H143 = 40755.

// Find the next triangle number that is also pentagonal and hexagonal.

// struct Pentagon {
//     n: u64,
//     v: u64,
// }

// impl Pentagon {
//     fn increment(&mut self) {
//         self.n += 1;
//         self.v = self.n * (3 * self.n - 1) / 2;
//     }
//     fn value(&self) -> u64 {
//         self.v
//     }
// }

// struct Hexagon {
//     n: u64,
//     v: u64,
// }

// impl Hexagon {
//     fn increment(&mut self) {
//         self.n += 1;
//         self.v = self.n * (2 * self.n - 1);
//     }
//     fn value(&self) -> u64 {
//         self.v
//     }
// }

struct Pentagon {
    n: u64,
    v: u64,
}

impl Pentagon {
    fn increment(&mut self) {
        self.v += self.n * 3 + 1;
        self.n += 1;
    }
    fn value(&self) -> u64 {
        self.v
    }
}

struct Hexagon {
    n: u64,
    v: u64,
}

impl Hexagon {
    fn increment(&mut self) {
        self.v += 4 * self.n + 1;
        self.n += 1;
    }
    fn value(&self) -> u64 {
        self.v
    }
}


// 92 us, 68 us
/// ```rust
/// use self::project_euler::m45::tri_penta_and_hexa;
/// assert_eq!(tri_penta_and_hexa(), 1533776805);
/// ```
pub fn tri_penta_and_hexa() -> u64 {
    let mut p = Pentagon { n: 165, v: 40755 };
    let mut h = Hexagon { n: 143, v: 40755 };
    p.increment();
    loop {
        while p.value() < h.value() {
            p.increment();
        }
        while h.value() < p.value() {
            h.increment();
        }
        if p.value() == h.value() {
            return p.value()
        }
    }
}
