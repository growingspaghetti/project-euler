// <p>Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:</p>
// <table><tr><td>Triangle</td>
// <td> </td>
// <td>P<sub>3,<i>n</i></sub>=<i>n</i>(<i>n</i>+1)/2</td>
// <td> </td>
// <td>1, 3, 6, 10, 15, ...</td>
// </tr><tr><td>Square</td>
// <td> </td>
// <td>P<sub>4,<i>n</i></sub>=<i>n</i><sup>2</sup></td>
// <td> </td>
// <td>1, 4, 9, 16, 25, ...</td>
// </tr><tr><td>Pentagonal</td>
// <td> </td>
// <td>P<sub>5,<i>n</i></sub>=<i>n</i>(3<i>n</i>−1)/2</td>
// <td> </td>
// <td>1, 5, 12, 22, 35, ...</td>
// </tr><tr><td>Hexagonal</td>
// <td> </td>
// <td>P<sub>6,<i>n</i></sub>=<i>n</i>(2<i>n</i>−1)</td>
// <td> </td>
// <td>1, 6, 15, 28, 45, ...</td>
// </tr><tr><td>Heptagonal</td>
// <td> </td>
// <td>P<sub>7,<i>n</i></sub>=<i>n</i>(5<i>n</i>−3)/2</td>
// <td> </td>
// <td>1, 7, 18, 34, 55, ...</td>
// </tr><tr><td>Octagonal</td>
// <td> </td>
// <td>P<sub>8,<i>n</i></sub>=<i>n</i>(3<i>n</i>−2)</td>
// <td> </td>
// <td>1, 8, 21, 40, 65, ...</td>
// </tr></table><p>The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.</p>
// <ol><li>The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).</li>
// <li>Each polygonal type: triangle (P<sub>3,127</sub>=8128), square (P<sub>4,91</sub>=8281), and pentagonal (P<sub>5,44</sub>=2882), is represented by a different number in the set.</li>
// <li>This is the only set of 4-digit numbers with this property.</li>
// </ol><p>Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.</p>

mod tests {
    use super::*;

    #[test]
    fn test_() {
        assert_eq!(polygonal_cyclical_numbers_1(), 28684);
    }
}

// fn polygonal_number_builder(side: u32) -> Fn {
//     let f = 8 * (side - 2) * x + (side - 4) * (side - 4);
//     |x: u32| (((f) as f32).sqrt() as u32 + (side - 4)) / 2 * (side - 2)
// }

#[derive(Debug)]
struct PolyNum {
    left: u8,
    right: u8,
    side_ident: u8,
}

fn next(filter: u8, polynums: &[PolyNum], chain: &[&PolyNum]) -> Option<u32> {
    if filter == 0b11111100 {
        if chain[chain.len() - 1].right != chain[0].left {
            return None;
        }
        //dbg!(chain);
        let sum = chain
            .iter()
            .map(|&pn| pn.left as u32 * 100 + pn.right as u32)
            .sum();
        return Some(sum);
    }
    let oks = polynums
        .iter()
        .filter(|&pn| pn.left == chain[chain.len() - 1].right && pn.side_ident & filter == 0)
        .collect::<Vec<&PolyNum>>();
    for pn in oks {
        let chain = chain
            .iter()
            .map(|&p| p)
            .chain(std::iter::once(pn))
            .collect::<Vec<&PolyNum>>();
        let child = next(filter | pn.side_ident, polynums, &chain);
        if child.is_some() {
            return child;
        }
    }
    None
}

fn generate_four_digit_polygonal_numbers_2(side: u32) -> Vec<PolyNum> {
    let polygonal_number_genenerator_builder =
        |side: u32| move |n: u32| (side - 2) * n * (n - 1) / 2 + n;

    let gen = polygonal_number_genenerator_builder(side);
    let mut polynums = vec![];
    for n in 1u32.. {
        let x = gen(n);
        if x > 9999 {
            break;
        }
        if x < 1000 {
            continue;
        }
        polynums.push(PolyNum {
            left: (x / 100) as u8,
            right: (x % 100) as u8,
            side_ident: 1 << (side - 1),
        });
    }
    polynums
}


fn generate_four_digit_polygonal_numbers(side: u32) -> Vec<PolyNum> {
    let diff_gen =
        |side: u32| move |n: u32| (side - 2) * n  + 1;

    let diff = diff_gen(side);
    let mut polynums = vec![];
    let mut x = 1u32;
    for n in 1u32.. {
        x += diff(n);
        if x > 9999 {
            break;
        }
        if x < 1000 {
            continue;
        }
        polynums.push(PolyNum {
            left: (x / 100) as u8,
            right: (x % 100) as u8,
            side_ident: 1 << (side - 1),
        });
    }
    polynums
}

// 40 us
/// ```rust
/// use self::project_euler::m61::polygonal_cyclical_numbers_1;
/// assert_eq!(polygonal_cyclical_numbers_1(), 28684);
/// ```
pub fn polygonal_cyclical_numbers_1() -> u32 {
    let octs = generate_four_digit_polygonal_numbers(8);

    let mut polynums = vec![];
    for s in 3u32..=7 {
        polynums.extend(generate_four_digit_polygonal_numbers(s).into_iter());
    }

    // let ans = octs.iter()
    //     .map(|oct| next(oct.side_ident, &polynums, &vec![oct]))
    //     .filter(|o| o.is_some())
    //     .map(|o|o.unwrap())
    //     .collect::<Vec<u32>>();
    // assert!(ans.len() == 1);
    // assert_eq!(ans[0], 123);
    for oct in &octs {
        if let Some(sum) = next(oct.side_ident, &polynums, &vec![oct]) {
            return sum;
        }
    }

    // for oct in octas {
    //     let mut right = oct.right;
    //     let mut filter = 0b00000000u8;
    //     for _ in 3..=6 {
    //         let next_polynums = polynums
    //             .iter()
    //             .filter(|&pn| pn.left == right && pn.side_ident & filter == 0)
    //             .collect::<Vec<&PolyNum>>();
    //         for pn in next_polynums {
    //             filter |= pn.side_ident;
    //             right = pn.right;
    //         }
    //     }
    //     let next_polynums = polynums
    //         .iter()
    //         .filter(|&pn| pn.left == right && pn.right == oct.left && pn.side_ident & filter == 0)
    //         .collect::<Vec<&PolyNum>>();
    //     if next_polynums.len() > 0 {
    //         println!("{:?}", next_polynums);
    //     }
    // }
    // let polygonal_number_builder = |side: i32| {
    //     move |x: i32| {
    //         let f = 8 * (side - 2) * x + (side - 4) * (side - 4);
    //         (((f) as f32).sqrt().ceil() as i32 + (side - 4)) / 2 * (side - 2)
    //     }
    // };

    unreachable!();
}
