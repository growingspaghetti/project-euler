//! ```txt
//! ryoji@ubuntu:/media/dev/project-euler$ cargo bench --bench bench_main -- distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100 --verbose --baseline new
//! warning: function is never used: `bench_the_first_triangle_number_to_have_over_five_hundred_divisors_brute`
//!
//!     Finished bench [optimized] target(s) in 0.05s
//!      Running target/release/deps/bench_main-6ef44f4b2c4834b9
//! Benchmarking distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute
//! Benchmarking distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute: Warming up for 3.0000 s
//! Benchmarking distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute: Collecting 100 samples in estimated 7.1671 s (300 iterations)
//! Benchmarking distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute: Analyzing
//! distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute
//!                         time:   [25.315 ms 26.165 ms 27.098 ms]
//!                         change: [-4.5557% +0.0000% +4.9933%] (p = 1.00 > 0.05)
//!                         No change in performance detected.
//! Found 15 outliers among 100 measurements (15.00%)
//!   6 (6.00%) high mild
//!   9 (9.00%) high severe
//! mean   [25.315 ms 27.098 ms] std. dev.      [3.5343 ms 5.3874 ms]
//! median [23.816 ms 24.543 ms] med. abs. dev. [892.91 us 1.9177 ms]
//!
//! Benchmarking distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute_not_using_string
//! Benchmarking distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute_not_using_string: Warming up for 3.0000 s
//! Benchmarking distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute_not_using_string: Collecting 100 samples in estimated 6.1776 s (400 iterations)
//! Benchmarking distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute_not_using_string: Analyzing
//! distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute_not_using_string
//!                         time:   [14.555 ms 14.626 ms 14.707 ms]
//!                         change: [-0.7491% +0.0000% +0.7515%] (p = 1.00 > 0.05)
//!                         No change in performance detected.
//! Found 3 outliers among 100 measurements (3.00%)
//!   1 (1.00%) high mild
//!   2 (2.00%) high severe
//! mean   [14.555 ms 14.707 ms] std. dev.      [261.44 us 516.05 us]
//! median [14.414 ms 14.547 ms] med. abs. dev. [116.30 us 300.85 us]
//!
//! Benchmarking distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_prime_factors
//! Benchmarking distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_prime_factors: Warming up for 3.0000 s
//! Benchmarking distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_prime_factors: Collecting 100 samples in estimated 5.1102 s (2400 iterations)
//! Benchmarking distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_prime_factors: Analyzing
//! distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_prime_factors
//!                         time:   [2.1394 ms 2.1632 ms 2.1895 ms]
//!                         change: [-1.6235% +0.0000% +1.6291%] (p = 1.00 > 0.05)
//!                         No change in performance detected.
//! Found 12 outliers among 100 measurements (12.00%)
//!   5 (5.00%) high mild
//!   7 (7.00%) high severe
//! mean   [2.1394 ms 2.1895 ms] std. dev.      [91.979 us 158.31 us]
//! median [2.0930 ms 2.1460 ms] med. abs. dev. [26.183 us 88.118 us]
//! ```
//! See (m16)[m16.rs],See (m20)[20.rs]
//! See (m32)[21.rs]

/// Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
///
/// 2 ^ 2 = 4, 2 ^ 3 = 8, 2 ^ 4 = 16, 2 ^ 5 = 32
/// 3 ^ 2 = 9, 3 ^ 3 = 27, 3 ^ 4 = 81, 3 ^ 5 = 243
/// 4 ^ 2 = 16, 4 ^ 3 = 64, 4 ^ 4 = 256, 4 ^ 5 = 1024
/// 5 ^ 2 = 25, 5 ^ 3 = 125, 5 ^ 4 = 625, 5 ^ 5 = 3125
///
/// If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
///
/// 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
///
/// How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
///
/// ```rust
/// use self::project_euler::m29::distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute;
/// assert_eq!(distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute(), 9183);
/// ```
pub fn distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute() -> u64 {
    fn multiply(containers: &mut std::vec::Vec<u64>, num: u64) {
        let mut carry = 0u64;
        for i in 0..containers.len() {
            containers[i] = containers[i] * num + carry;
            if containers[i] > 1_000_000_000 {
                carry = containers[i] / 1_000_000_000;
                containers[i] -= 1_000_000_000 * carry;
            } else {
                carry = 0;
            }
        }
        if carry > 0 {
            containers.push(carry);
        }
    }
    fn pow(num: u64, exp: u64) -> String {
        let containers = &mut std::vec::Vec::<u64>::new();
        containers.push(1);
        for _ in 0..exp {
            multiply(containers, num);
        }
        containers
            .iter()
            .rev()
            .map(|&u| format!("{:09}", u))
            .collect::<Vec<String>>()
            .join("")
    };
    fn fab(a: u64, b: u64) -> String {
        pow(a, b)
    };

    use std::collections::HashSet;
    let mut map: HashSet<String> = HashSet::new();
    for a in 2..=100u64 {
        for b in 2..=100u64 {
            map.insert(fab(a, b));
        }
    }
    // ..
    // 000002059862363607268589106591502209383050789423074359962839707804960198700428009033203125
    // 000047101286972462448349216036890000000000000000000000000000000000000000000000000000000000
    // 000000904625697166532776746648320380374280103671755200316906558262375061821325312
    // 000318644812890625
    // ..
    //map.iter().for_each(|s|println!("{}", s));
    map.len() as u64
}

/// Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
///
/// 2 ^ 2 = 4, 2 ^ 3 = 8, 2 ^ 4 = 16, 2 ^ 5 = 32
/// 3 ^ 2 = 9, 3 ^ 3 = 27, 3 ^ 4 = 81, 3 ^ 5 = 243
/// 4 ^ 2 = 16, 4 ^ 3 = 64, 4 ^ 4 = 256, 4 ^ 5 = 1024
/// 5 ^ 2 = 25, 5 ^ 3 = 125, 5 ^ 4 = 625, 5 ^ 5 = 3125
///
/// If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
///
/// 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
///
/// How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
///
/// ```rust
/// use self::project_euler::m29::distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute_not_using_string;
/// assert_eq!(distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute_not_using_string(), 9183);
/// ```
pub fn distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_brute_not_using_string() -> u64 {
    fn multiply(containers: &mut std::vec::Vec<u64>, num: u64) {
        let mut carry = 0u64;
        for i in 0..containers.len() {
            containers[i] = containers[i] * num + carry;
            if containers[i] > 1_000_000_000 {
                carry = containers[i] / 1_000_000_000;
                containers[i] -= 1_000_000_000 * carry;
            } else {
                carry = 0;
            }
        }
        if carry > 0 {
            containers.push(carry);
        }
    }
    fn pow(num: u64, exp: u64) -> Vec<u64> {
        let mut containers = std::vec::Vec::<u64>::new();
        containers.push(1);
        for _ in 0..exp {
            multiply(&mut containers, num);
        }
        containers
    };
    fn fab(a: u64, b: u64) -> Vec<u64> {
        pow(a, b)
    };

    use std::collections::HashSet;
    let mut map: HashSet<Vec<u64>> = HashSet::new();
    for a in 2..=100u64 {
        for b in 2..=100u64 {
            map.insert(fab(a, b));
        }
    }
    map.len() as u64
}

/// Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
///
/// 2 ^ 2 = 4, 2 ^ 3 = 8, 2 ^ 4 = 16, 2 ^ 5 = 32
/// 3 ^ 2 = 9, 3 ^ 3 = 27, 3 ^ 4 = 81, 3 ^ 5 = 243
/// 4 ^ 2 = 16, 4 ^ 3 = 64, 4 ^ 4 = 256, 4 ^ 5 = 1024
/// 5 ^ 2 = 25, 5 ^ 3 = 125, 5 ^ 4 = 625, 5 ^ 5 = 3125
///
/// If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
///
/// 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
///
/// How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
///
/// ```rust
/// use self::project_euler::m29::distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_prime_factors;
/// assert_eq!(distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_prime_factors(), 9183);
/// ```
pub fn distinct_terms_are_in_a_pow_b_for_2_a_100_2_b_100_prime_factors() -> u64 {
    fn factoring(num: u64) -> Vec<(u64, u64)> {
        let mut prime_factors: Vec<(u64, u64)> = vec![];
        let mut tmp = num;
        if num == 1 {
            return prime_factors;
        }
        for d in 2..=3u64 {
            let mut exponent = 0u64;
            while tmp % d == 0 {
                exponent += 1;
                tmp /= d;
            }
            if exponent > 0 {
                prime_factors.push((d, exponent));
            }
        }
        // side a, regarding num is the are of a rectangle.
        // when side_a and side_b both are bigger than sqrt(S), the area doesn't fit in.
        let side_max = (num as f64).sqrt().ceil() as u64;
        let mut d = 5u64;
        let mut skip_four = false;
        loop {
            if d > side_max || tmp == 1 {
                break;
            }
            let mut exponent = 0u64;
            while tmp % d == 0 {
                exponent += 1;
                tmp /= d;
            }
            if exponent > 0 {
                prime_factors.push((d, exponent));
            }
            if skip_four {
                d += 4;
                skip_four = false;
            } else {
                d += 2;
                skip_four = true;
            }
        }
        // side b left is a prime
        if tmp != 1 {
            prime_factors.push((tmp, 1));
        }
        prime_factors
    }

    use std::collections::HashSet;
    let mut map: HashSet<Vec<(u64, u64)>> = HashSet::new();
    for a in 2..=100u64 {
        let prime_factors = factoring(a);
        for b in 2..=100u64 {
            // 6^2 = 6 * 6 = 2*3 * 2*3 = 2^2 * 3^2
            let calculating_formula = prime_factors
                .iter()
                .map(|t| (t.0, t.1 * b))
                .collect::<Vec<(u64, u64)>>();
            map.insert(calculating_formula);
        }
    }
    // ..
    // [(71, 37)]
    // [(2, 156),(11, 78)]
    // [(2, 32),(37, 32)]
    // [(2, 96),(19, 48)]
    // [(2, 198),(7, 66)]
    // [(43, 92)]
    // ..
    // map.iter().for_each(|v|println!("{:?}", v));
    map.len() as u64
}
